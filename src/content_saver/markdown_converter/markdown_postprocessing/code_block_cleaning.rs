//! Code block cleaning utilities for markdown postprocessing.
//!
//! Removes UI artifacts from code viewer widgets, specifically
//! "X collapsed lines" text that appears in scraped code blocks.

use super::code_fence_detection::{detect_code_fence, CodeFence};
use regex::Regex;
use std::sync::LazyLock;

/// Matches "X collapsed lines" or "X collapsed line" text
/// 
/// Pattern: `^\s*\d+ collapsed lines?$`
/// 
/// Matches:
/// - "26 collapsed lines"
/// - "1 collapsed line"
/// - "  100 collapsed lines" (with leading whitespace)
/// 
/// Does NOT match:
/// - "// 26 collapsed lines" (has code-like prefix)
/// - "collapsed lines" (no number)
/// - "26 collapsed" (incomplete)
static COLLAPSED_LINES_RE: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"^\s*\d+ collapsed lines?$")
        .expect("COLLAPSED_LINES_RE: hardcoded regex is statically valid")
});

/// Matches lines that are ONLY asterisks (2 or more) after code fence closing
///
/// Pattern: Matches a line with:
/// - Optional leading whitespace
/// - 2 or more asterisks
/// - Optional trailing whitespace
/// - End of line
///
/// This catches the corruption pattern where htmd emits `**` after a code fence.
static TRAILING_ASTERISKS_RE: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"(?m)^```\s*\n\s*\*\*+\s*$")
        .expect("TRAILING_ASTERISKS_RE: hardcoded regex is statically valid")
});

/// Filter out "X collapsed lines" text from code blocks
///
/// This removes UI artifacts from code viewer widgets that get captured
/// during HTML-to-markdown conversion. The function:
/// 
/// 1. Tracks code fence state (opening/closing ```)
/// 2. When inside a code block, filters lines matching the pattern
/// 3. Preserves all other lines unchanged
/// 4. Works with both triple-backtick and triple-tilde fences
///
/// # Arguments
///
/// * `markdown` - Markdown content potentially containing collapsed line indicators
///
/// # Returns
///
/// * Cleaned markdown with collapsed line indicators removed from code blocks
///
/// # Examples
///
/// ```rust
/// let markdown = r#"
/// Some text
/// ```rust
/// 26 collapsed lines
/// fn main() {
///     println!("Hello");
/// }
/// ```
/// "#;
/// 
/// let cleaned = filter_collapsed_lines(markdown);
/// // Result: code block without "26 collapsed lines"
/// ```
pub fn filter_collapsed_lines(markdown: &str) -> String {
    let lines: Vec<&str> = markdown.lines().collect();
    let mut filtered_lines = Vec::with_capacity(lines.len());
    let mut fence_stack: Option<CodeFence> = None;

    for (line_num, line) in lines.iter().enumerate() {
        let trimmed = line.trim_start();

        // Track code fence state
        if let Some((fence_char, fence_count)) = detect_code_fence(trimmed) {
            if let Some(ref current_fence) = fence_stack {
                // Check if this closes the current fence
                if fence_char == current_fence.char && fence_count >= current_fence.count {
                    fence_stack = None;
                }
            } else {
                // Open a new code fence
                fence_stack = Some(CodeFence {
                    char: fence_char,
                    count: fence_count,
                    line_number: line_num,
                });
            }
            // Always preserve fence lines
            filtered_lines.push(line.to_string());
            continue;
        }

        // Filter logic: Only filter inside code blocks
        if fence_stack.is_some() {
            // Inside a code block - check if line matches pattern
            if COLLAPSED_LINES_RE.is_match(line.trim()) {
                // Skip this line (it's a collapsed lines indicator)
                tracing::debug!(
                    "Filtered collapsed lines indicator at line {}: '{}'",
                    line_num + 1,
                    line.trim()
                );
                continue;
            }
        }

        // Preserve all other lines
        filtered_lines.push(line.to_string());
    }

    filtered_lines.join("\n")
}

/// Strip bold formatting markers (`**`) that corrupt code fence markers.
///
/// Detects and fixes lines where bold asterisks are incorrectly prepended
/// to code fence markers, creating patterns like `**```rust` instead of
/// the correct ````rust`.
///
/// This handles malformed markdown generated by htmd when HTML structure
/// has bold tags (`<strong>`, `<b>`) that aren't properly closed before
/// code blocks (`<pre>`, `<code>`).
///
/// # Pattern Detection
///
/// Matches lines with these characteristics:
/// - Optional leading whitespace
/// - Exactly `**` (two asterisks)
/// - Immediately followed by ` ``` ` or `~~~` (code fence marker)
/// - Optional language identifier after fence
///
/// # Examples
///
/// Fixes these patterns:
/// - `**```rust` → ````rust`
/// - `  **```python` → `  ```python`
/// - `**~~~` → `~~~`
/// - `**```text` → ````text`
///
/// Preserves valid markdown:
/// - `**bold text** not a fence` (unchanged - not a fence)
/// - `Some **bold** then ``` (unchanged - asterisks not directly before fence)
/// - `[**```text**](url)` (unchanged - inside link)
///
/// # Arguments
///
/// * `markdown` - Markdown content potentially containing corrupted code fences
///
/// # Returns
///
/// Cleaned markdown with bold markers stripped from code fence lines
pub fn strip_bold_from_code_fences(markdown: &str) -> String {
    let lines: Vec<&str> = markdown.lines().collect();
    let mut cleaned_lines = Vec::with_capacity(lines.len());

    for line in lines {
        // Detect pattern: optional whitespace + ** + code fence marker
        let trimmed = line.trim_start();
        
        if trimmed.starts_with("**```") || trimmed.starts_with("**~~~") {
            // Calculate indentation to preserve
            let indent = &line[..line.len() - trimmed.len()];
            
            // Strip the ** prefix (2 chars) and reconstruct with original indent
            let cleaned = format!("{}{}", indent, &trimmed[2..]);
            
            tracing::debug!(
                "Stripped bold markers from code fence: '{}' → '{}'",
                line,
                cleaned
            );
            
            cleaned_lines.push(cleaned);
        } else {
            // Preserve all other lines unchanged
            cleaned_lines.push(line.to_string());
        }
    }

    cleaned_lines.join("\n")
}

/// Strip trailing asterisks that appear immediately after code fence closings
///
/// This is a defensive safety net that catches cases where bold formatting
/// "leaked" across code block boundaries during HTML-to-markdown conversion.
///
/// # Pattern Detection
///
/// Removes lines matching this pattern:
/// ```
/// ```           ← closing code fence
/// ****          ← line with only asterisks (THIS gets removed)
/// ```
///
/// # Arguments
///
/// * `markdown` - Markdown content potentially containing trailing asterisks
///
/// # Returns
///
/// * Cleaned markdown with trailing asterisks removed
///
/// # Examples
///
/// ```rust
/// let markdown = r#"
/// ```rust
/// fn main() {}
/// ```
/// ****
/// "#;
/// 
/// let cleaned = strip_trailing_asterisks_after_code_fences(markdown);
/// // Result: closing fence with no trailing asterisks
/// ```
pub fn strip_trailing_asterisks_after_code_fences(markdown: &str) -> String {
    // Replace code fence followed by asterisk-only line with just the fence
    TRAILING_ASTERISKS_RE.replace_all(markdown, "```\n").to_string()
}

/// Regex to match HTML tags: <tag>, </tag>, <tag attr="value">
static HTML_TAG_RE: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"</?[a-zA-Z][a-zA-Z0-9]*(?:\s+[^>]*)?>")
        .expect("HTML_TAG_RE: hardcoded regex is valid")
});

/// Strip residual HTML tags that leaked through conversion
///
/// This is a defensive measure to catch any HTML that htmd's handlers
/// failed to convert. It preserves code blocks (doesn't strip inside fences).
///
/// This is Layer 2 of the defense-in-depth strategy against HTML leakage:
/// - Layer 1 (PRIMARY): Fixed custom handlers use `handlers.walk_children()`
/// - Layer 2 (DEFENSIVE): This function strips any HTML that still leaks through
/// - Layer 3 (PREVENTIVE): HTML structure normalization before conversion
///
/// # Arguments
///
/// * `markdown` - Markdown content potentially containing residual HTML tags
///
/// # Returns
///
/// * Cleaned markdown with HTML tags removed (except inside code blocks)
///
/// # Examples
///
/// ```rust
/// let markdown = r#"
/// Some text <p>with HTML tags</p>
/// 
/// ```rust
/// let html = "<div>code</div>";  // HTML inside code - preserved!
/// ```
/// 
/// More <span>text</span> here
/// "#;
/// 
/// let cleaned = strip_residual_html_tags(markdown);
/// // Result: HTML tags removed except inside code blocks
/// ```
pub fn strip_residual_html_tags(markdown: &str) -> String {
    let mut result = String::with_capacity(markdown.len());
    let mut in_code_fence = false;
    
    for line in markdown.lines() {
        // Track code fence boundaries
        let trimmed = line.trim_start();
        if trimmed.starts_with("```") || trimmed.starts_with("~~~") {
            in_code_fence = !in_code_fence;
            result.push_str(line);
            result.push('\n');
            continue;
        }
        
        // Don't strip HTML inside code fences
        if in_code_fence {
            result.push_str(line);
            result.push('\n');
            continue;
        }
        
        // Strip HTML tags from non-code lines
        let cleaned = HTML_TAG_RE.replace_all(line, "");
        result.push_str(&cleaned);
        result.push('\n');
    }
    
    result.trim_end().to_string()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_filter_single_collapsed_line() {
        let markdown = r#"```rust
26 collapsed lines
fn main() {}
```"#;

        let result = filter_collapsed_lines(markdown);
        assert!(!result.contains("26 collapsed lines"));
        assert!(result.contains("fn main() {}"));
    }

    #[test]
    fn test_preserve_code_with_similar_text() {
        let markdown = r#"```rust
// This mentions 26 collapsed lines in a comment
fn main() {}
```"#;

        let result = filter_collapsed_lines(markdown);
        // Should preserve because it doesn't match exact pattern
        assert!(result.contains("// This mentions 26 collapsed lines"));
    }

    #[test]
    fn test_filter_multiple_blocks() {
        let markdown = r#"
Text before

```rust
10 collapsed lines
fn foo() {}
```

More text

```python
5 collapsed lines
def bar():
    pass
```
"#;

        let result = filter_collapsed_lines(markdown);
        assert!(!result.contains("10 collapsed lines"));
        assert!(!result.contains("5 collapsed lines"));
        assert!(result.contains("fn foo() {}"));
        assert!(result.contains("def bar():"));
    }

    #[test]
    fn test_no_change_outside_code_blocks() {
        let markdown = r#"
Regular text
26 collapsed lines
More text
"#;

        let result = filter_collapsed_lines(markdown);
        // Should preserve because it's outside code blocks
        assert!(result.contains("26 collapsed lines"));
    }

    #[test]
    fn test_strip_bold_from_code_fence_basic() {
        let markdown = "**```rust\nfn main() {}\n```";
        let result = strip_bold_from_code_fences(markdown);
        assert_eq!(result, "```rust\nfn main() {}\n```");
        assert!(!result.contains("**```"), "Should not have bold before fence");
    }

    #[test]
    fn test_strip_bold_with_indentation() {
        let markdown = "  **```python\nprint('hello')\n```";
        let result = strip_bold_from_code_fences(markdown);
        assert_eq!(result, "  ```python\nprint('hello')\n```");
        assert!(result.starts_with("  ```"), "Should preserve indentation");
    }

    #[test]
    fn test_strip_bold_tildes() {
        let markdown = "**~~~\ncode here\n~~~";
        let result = strip_bold_from_code_fences(markdown);
        assert_eq!(result, "~~~\ncode here\n~~~");
    }

    #[test]
    fn test_preserve_valid_bold() {
        let markdown = "**bold text** not a fence\n```rust\ncode\n```";
        let result = strip_bold_from_code_fences(markdown);
        assert!(result.contains("**bold text**"), "Should preserve valid bold");
    }

    #[test]
    fn test_preserve_bold_separate_from_fence() {
        let markdown = "Some **bold** then\n```rust\ncode\n```";
        let result = strip_bold_from_code_fences(markdown);
        assert!(result.contains("**bold**"), "Should preserve bold not adjacent to fence");
    }

    #[test]
    fn test_multiple_corrupted_fences() {
        let markdown = "**```rust\ncode1\n```\n\nText\n\n**```python\ncode2\n```";
        let result = strip_bold_from_code_fences(markdown);
        assert!(!result.contains("**```"), "Should fix all corrupted fences");
        assert_eq!(result.matches("```rust").count(), 1);
        assert_eq!(result.matches("```python").count(), 1);
    }

    #[test]
    fn test_no_change_when_no_corruption() {
        let markdown = "```rust\nfn main() {}\n```\n\n**Some bold text**";
        let result = strip_bold_from_code_fences(markdown);
        assert_eq!(result, markdown, "Should not modify clean markdown");
    }
}
