//! Markdown processing and heading normalization functionality.
//!
//! Processes markdown content by normalizing headings and handling various markdown formats.

use regex::Regex;
use std::sync::LazyLock;

mod code_fence_detection;
mod heading_extraction;
mod processor;
pub mod whitespace_normalization;
pub mod code_block_cleaning;
pub mod block_spacing;
mod shell_syntax_repair;
mod bracket_unescaping;

/// Regex pattern to match common UI button text artifacts
/// 
/// Matches patterns anywhere in text (mid-line or end-of-line):
/// - "CopyAsk AI" or "Copy Ask AI" (any spacing variant)
/// - "Ask AI" standalone
/// - "Copy", "Copy clipboard", "Copy to clipboard", "Copy code"
static UI_ARTIFACT_PATTERN: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(
        r"Copy\s*Ask\s*AI|Ask\s*AI|Copy(?:\s+(?:to\s+)?(?:clipboard|code))?"
    )
    .expect("UI_ARTIFACT_PATTERN: hardcoded regex is valid")
});

/// Regex pattern to match system/debug messages from file reading tools
///
/// Matches patterns:
/// - `[Reading X lines from line Y of Z total lines]`
/// - `[Reading X lines from line Y]`
///
/// These messages are generated by MCP tools (like fs_read_file) and should
/// never appear in final markdown output.
///
/// # Pattern Details
/// - `^\[Reading ` - Must start at beginning of line with literal `[Reading `
/// - `\d+` - One or more digits (line count)
/// - ` lines from line ` - Literal text
/// - `\d+` - Starting line number
/// - `(?: of \d+ total lines)?` - Optional "of X total lines" suffix (non-capturing group)
/// - `\]\s*$` - Closing bracket followed by optional whitespace at end of line
///
/// # Rust Pattern Notes
/// - Uses `LazyLock` for thread-safe lazy initialization (Rust 2024 pattern)
/// - Hardcoded regex validated at compile-time via `.expect()` panic
/// - Non-capturing group `(?:...)` for performance (no backreferences needed)
static SYSTEM_MESSAGE_PATTERN: LazyLock<Regex> = LazyLock::new(|| {
    Regex::new(r"^\[Reading \d+ lines from line \d+(?: of \d+ total lines)?\]\s*$")
        .expect("SYSTEM_MESSAGE_PATTERN: hardcoded regex is valid")
});

/// Filter out UI artifact text from markdown
///
/// This is a secondary defense layer that removes common UI button text
/// that escaped the HTML-level cleaning. Matches patterns anywhere in the
/// text, including mid-line and end-of-line positions.
///
/// # Arguments
/// * `markdown` - Markdown content to filter
///
/// # Returns
/// * Filtered markdown with UI artifacts removed
///
/// # Examples
///
/// ```rust
/// let input = "Description text:CopyAsk AI\n\n```rust\ncode\n```";
/// let output = filter_ui_artifacts(input);
/// assert_eq!(output, "Description text:\n\n```rust\ncode\n```");
/// ```
pub fn filter_ui_artifacts(markdown: &str) -> String {
    // Fast path: if markdown doesn't contain any likely UI patterns, return as-is
    if !markdown.contains("Copy") && !markdown.contains("Ask") {
        return markdown.to_string();
    }
    
    // Apply regex replacement
    let result = UI_ARTIFACT_PATTERN.replace_all(markdown, "");
    
    // Clean up any resulting triple newlines â†’ double newlines
    result.replace("\n\n\n", "\n\n")
}

/// Filter out system/debug messages from markdown
///
/// Removes file reading status messages that were inadvertently embedded
/// in markdown content. These messages follow the pattern:
/// `[Reading X lines from line Y of Z total lines]`
///
/// This is a defensive filter that catches tool output contamination
/// before it reaches the final markdown. The messages originate from
/// kodegen-tools-filesystem's fs_read_file tool when it returns partial
/// file reads with informational notices prepended.
///
/// # Arguments
/// * `markdown` - Markdown content potentially containing system messages
///
/// # Returns
/// * Filtered markdown with system messages and trailing blank lines removed
///
/// # Performance
/// - **Fast-path check**: Returns immediately if `[Reading ` substring not found (O(n) single pass)
/// - **Pre-allocated capacity**: `String::with_capacity(markdown.len())` prevents reallocations
/// - **Blank line removal**: Also removes blank lines immediately following system messages to prevent double-spacing
/// - **Tracing integration**: Uses `tracing::debug!` for observability (zero overhead when disabled)
///
/// # Rust Implementation Notes
/// - Uses `line.trim()` for robust whitespace handling
/// - `skip_next_blank` flag pattern for stateful line processing
/// - Final trailing newline removal matches standard markdown formatting
/// - Returns owned `String` (not `Cow<str>`) for consistent API with other filters
///
/// # Examples
///
/// ```rust
/// # use kodegen_tools_citescrape::content_saver::markdown_converter::markdown_postprocessing::filter_system_messages;
/// let input = "[Reading 1000 lines from line 0 of 1158 total lines]\n\n# Title\nContent";
/// let output = filter_system_messages(input);
/// assert_eq!(output, "# Title\nContent");
/// ```
///
/// ```rust
/// # use kodegen_tools_citescrape::content_saver::markdown_converter::markdown_postprocessing::filter_system_messages;
/// let input = "[Reading 500 lines from line 100]\n\n## Heading\nText";
/// let output = filter_system_messages(input);
/// assert_eq!(output, "## Heading\nText");
/// ```
///
/// ```rust
/// # use kodegen_tools_citescrape::content_saver::markdown_converter::markdown_postprocessing::filter_system_messages;
/// // Fast-path optimization: Clean content returns immediately
/// let clean = "# Title\nNo system messages here";
/// let output = filter_system_messages(clean);
/// assert_eq!(output, clean);
/// ```
pub fn filter_system_messages(markdown: &str) -> String {
    // Fast path: if markdown doesn't contain the telltale pattern, return as-is
    // This O(n) substring scan returns immediately for 99.9% of cases (clean content)
    if !markdown.contains("[Reading ") {
        return markdown.to_string();
    }

    // Process line by line to remove matching lines
    // Pre-allocate to exact input size to avoid reallocations
    let mut result = String::with_capacity(markdown.len());
    let mut skip_next_blank = false;

    for line in markdown.lines() {
        // Check if this line matches the system message pattern
        // trim() handles any leading/trailing whitespace on the line
        if SYSTEM_MESSAGE_PATTERN.is_match(line.trim()) {
            // Skip this line and flag to skip following blank line
            skip_next_blank = true;
            tracing::debug!("Filtered system message: '{}'", line.trim());
            continue;
        }

        // Skip blank line immediately following a system message
        // This prevents double-spacing in the output
        if skip_next_blank && line.trim().is_empty() {
            skip_next_blank = false;
            continue;
        }

        skip_next_blank = false;
        result.push_str(line);
        result.push('\n');
    }

    // Remove trailing newline to match standard markdown formatting behavior
    // This matches the behavior of markdown.lines().collect::<Vec<_>>().join("\n")
    if result.ends_with('\n') {
        result.pop();
    }

    result
}

#[cfg(test)]
mod tests;

/// Ensure markdown starts with H1 heading
///
/// Checks if markdown already starts with an H1 (`# `). If not, prepends
/// an H1 using either:
/// 1. The first extracted H1 heading from the document (if level == 1)
/// 2. The first heading of any level (if no H1 exists)
/// 3. The document title as fallback (if no headings extracted)
///
/// This fixes the issue where H1 headings inside `<header>` elements
/// are removed during HTML preprocessing, leaving markdown without a
/// top-level heading.
///
/// # Arguments
///
/// * `markdown` - The markdown content to process
/// * `headings` - Extracted heading elements from the page
/// * `title` - Document title as final fallback
///
/// # Returns
///
/// Markdown string with H1 at the start
///
/// # Examples
///
/// ```rust
/// # use kodegen_tools_citescrape::content_saver::markdown_converter::markdown_postprocessing::ensure_h1_at_start;
/// # use kodegen_tools_citescrape::page_extractor::schema::HeadingElement;
/// let headings = vec![
///     HeadingElement { level: 1, text: "Main Title".to_string(), id: None, ordinal: vec![1] },
/// ];
/// let markdown = "## Subtitle\n\nContent";
/// let result = ensure_h1_at_start(markdown, &headings, "Fallback Title");
/// assert!(result.starts_with("# Main Title"));
/// ```
///
/// ```rust
/// # use kodegen_tools_citescrape::content_saver::markdown_converter::markdown_postprocessing::ensure_h1_at_start;
/// let markdown = "# Already Has H1\n\nContent";
/// let result = ensure_h1_at_start(markdown, &[], "Title");
/// assert_eq!(result, "# Already Has H1\n\nContent");
/// ```
pub fn ensure_h1_at_start(
    markdown: &str,
    headings: &[crate::page_extractor::schema::HeadingElement],
    title: &str,
) -> String {
    // Check if markdown already starts with H1
    // trim_start() handles leading whitespace/newlines
    if markdown.trim_start().starts_with("# ") {
        return markdown.to_string();
    }

    // Determine H1 text to use:
    // 1. First extracted H1 (level == 1)
    // 2. First heading of any level (fallback if no H1)
    // 3. Document title (final fallback)
    let h1_text = if let Some(first_heading) = headings.first() {
        if first_heading.level == 1 {
            // Use the first H1
            &first_heading.text
        } else {
            // No H1 extracted, use document title
            // (Don't use lower-level headings as they may be contextual)
            title
        }
    } else {
        // No headings at all, use title
        title
    };

    // Prepend H1 with proper spacing
    // Format: "# {text}\n\n{original_markdown}"
    // The double newline ensures proper separation from content
    format!("# {}\n\n{}", h1_text, markdown)
}

// Re-export public API
pub use heading_extraction::{extract_heading_level, normalize_heading_level};
pub use processor::process_markdown_headings;
pub use processor::fix_merged_code_fences;
pub use whitespace_normalization::normalize_whitespace;
pub use whitespace_normalization::normalize_inline_formatting_spacing;
pub use whitespace_normalization::fix_bold_internal_spacing;
pub use whitespace_normalization::fix_html_tag_spacing;
pub use whitespace_normalization::fix_angle_bracket_spacing;
pub use whitespace_normalization::simplify_url_as_link_text;
pub use code_block_cleaning::filter_collapsed_lines;
pub use code_block_cleaning::strip_bold_from_code_fences;
pub use code_block_cleaning::normalize_code_fences;
pub use code_block_cleaning::strip_trailing_asterisks_after_code_fences;
pub use code_block_cleaning::strip_residual_html_tags;
pub use code_block_cleaning::remove_duplicate_code_blocks;
pub use code_block_cleaning::fix_shebang_lines;
pub use code_block_cleaning::fix_consecutive_commas;
pub use block_spacing::ensure_block_element_spacing;
pub use shell_syntax_repair::repair_shell_syntax;
pub use bracket_unescaping::unescape_orphan_brackets;

// UI artifact filtering (Issue #004)
// Note: This is defined directly in this module, not in a submodule
// pub use ui_artifact_filter::filter_ui_artifacts; // Would be this if it was a submodule
